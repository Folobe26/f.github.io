<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>
        F010BE
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico" />
    <link rel="stylesheet" href="/css/style/github.min.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
    <script src="/js/jquery.min.js"></script>
    <script src="/js/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
<meta name="generator" content="Hexo 5.2.0"></head>

<body>
    <div class="container">
        <div class="header">
    <!-- <div class="logo">
        <a href="/">F010BE</a>
    </div> -->
    <div class="logo">
        <img src="/images/logo.png" alt="Logo">
    </div>
    <div class="nav">
        <ul class="menu">
            
                <li class="menu-item">
                    <a href="/" class="menu-item-link">
                        Home
                    </a>
                </li>
            
                <li class="menu-item">
                    <a target="_blank" rel="noopener" href="https://github.com/loveminimal" class="menu-item-link">
                        Github
                    </a>
                </li>
                
        </ul>
    </div>
</div>
        <div class="article">
    <!-- <div class="article-title">
        <h2>
            一点GCD的学习
        </h2>
    </div> -->
    <div class="article-meta">
        <div class="article-date">
            <i class="fas fa-edit"></i>
            2020/09/18 Fri 16:08&nbsp;&nbsp;&nbsp;
            <span class="just-a-temp"><span>
            <i class="fas fa-redo"></i>
            2020/09/18 Fri 16:10
        </div>
    </div>
    <div class="article-content">
        <p><strong>目标：</strong></p>
<p>学习10+多线程下的正确使用case</p>
<p>阅读GCD白皮书，粗略阅读GCD源码，深入理解API背后的impl，掌握所有的API的正确使用姿势</p>
<p>分析5篇精选博客</p>
<p>还是做一下难度分类：</p>
<p><strong>第一篇博客：</strong><a target="_blank" rel="noopener" href="https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/">并发编程：API与挑战</a></p>
<p>博客主要讲两个主题：</p>
<p>iOS和macOS下的并发API介绍</p>
<p>与API无关的并发编程面临的挑战</p>
<p><strong>iOS和macOS下的多线程API</strong></p>
<p>Pthread</p>
<p>pthread是通用的多线程API，支持在Unix/Linux/Windows下使用</p>
<p>使用C语言编写</p>
<p>需要手动管理thread的生命周期</p>
<p>pthread_create()</p>
<p>pthread_detach()//从当前线程detach，运行结束自动释放所有资源</p>
<p>pthread_exit()//终止</p>
<p>pthread_cancel()//中断</p>
<p>pthread_join()//block当前线程，wait指定线程结束</p>
<p>pthread_attr_init()//线程属性初始化</p>
<p>pthread_kill()//不是kill线程，而是发送信号</p>
<p>常见的pthread signal：【是不是发现很多熟悉的东西。。。】</p>
<p><img src="./gcd/media/image1.png" alt="Generated">{width=”6.041666666666667in”<br>height=”3.3020833333333335in”}</p>
<p>NSThread</p>
<p>先对比使用pthread和NSThread的区别</p>
<p>#import &lt;pthread.h&gt;</p>
<p>struct threadInfo {</p>
<p>uint32_t * inputValues;</p>
<p>size_t count;</p>
<p>};</p>
<p>struct threadResult {</p>
<p>uint32_t min;</p>
<p>uint32_t max;</p>
<p>};</p>
<p>void * findMinAndMax(void *arg)</p>
<p>{</p>
<p>struct threadInfo const * const info = (struct threadInfo *) arg;</p>
<p>uint32_t min = UINT32_MAX;</p>
<p>uint32_t max = 0;</p>
<p>for (size_t i = 0; i &lt; info-&gt;count; ++i) {</p>
<p>uint32_t v = info-&gt;inputValues[i];</p>
<p>min = MIN(min, v);</p>
<p>max = MAX(max, v);</p>
<p>}</p>
<p>free(arg);</p>
<p>struct threadResult * const result = (struct threadResult *)<br>malloc(sizeof(*result));</p>
<p>result-&gt;min = min;</p>
<p>result-&gt;max = max;</p>
<p>return result;</p>
<p>}</p>
<p>int main(int argc, const char * argv[])</p>
<p>{</p>
<p>size_t const count = 1000000;</p>
<p>uint32_t inputValues[count];</p>
<p>// Fill input values with random numbers:</p>
<p>for (size_t i = 0; i &lt; count; ++i) {</p>
<p>inputValues[i] = arc4random();</p>
<p>}</p>
<p>// Spawn 4 threads to find the minimum and maximum:</p>
<p>size_t const threadCount = 4;</p>
<p>pthread_t tid[threadCount];</p>
<p>for (size_t i = 0; i &lt; threadCount; ++i) {</p>
<p>struct threadInfo * const info = (struct threadInfo *)<br>malloc(sizeof(*info));</p>
<p>size_t offset = (count / threadCount) * i;</p>
<p>info-&gt;inputValues = inputValues + offset;</p>
<p>info-&gt;count = MIN(count - offset, count / threadCount);</p>
<p>int err = pthread_create(tid + i, NULL, &amp;findMinAndMax,<br>info);//使用pthread创建线程</p>
<p>NSCAssert(err == 0, @&quot;pthread_create() failed: %d&quot;, err);</p>
<p>}</p>
<p>// Wait for the threads to exit:</p>
<p>struct threadResult * results[threadCount];</p>
<p>for (size_t i = 0; i &lt; threadCount; ++i) {</p>
<p>int err = pthread_join(tid[i], (void **) &amp;(results[i]));</p>
<p>//pthread_join会让当前线程等待第一个参数thread—id指定的线程</p>
<p>NSCAssert(err == 0, @&quot;pthread_join() failed: %d&quot;, err);</p>
<p>}</p>
<p>// Find the min and max:</p>
<p>uint32_t min = UINT32_MAX;</p>
<p>uint32_t max = 0;</p>
<p>for (size_t i = 0; i &lt; threadCount; ++i) {</p>
<p>min = MIN(min, results[i]-&gt;min);</p>
<p>max = MAX(max, results[i]-&gt;max);</p>
<p>free(results[i]);</p>
<p>results[i] = NULL;</p>
<p>}</p>
<p>NSLog(@&quot;min = %u&quot;, min);</p>
<p>NSLog(@&quot;max = %u&quot;, max);</p>
<p>return 0;</p>
<p>}</p>
<p>@interface FindMinMaxThread : NSThread</p>
<p>@property (nonatomic) NSUInteger min;</p>
<p>@property (nonatomic) NSUInteger max;</p>
<p>- (instancetype)initWithNumbers:(NSArray *)numbers;@end</p>
<p>@implementation FindMinMaxThread {</p>
<p>NSArray *_numbers;</p>
<p>}</p>
<p>- (instancetype)initWithNumbers:(NSArray *)numbers</p>
<p>{</p>
<p>self = [super init];</p>
<p>if (self) {</p>
<p>_numbers = numbers;</p>
<p>}</p>
<p>return self;</p>
<p>}</p>
<p>- (void)main</p>
<p>{</p>
<p>NSUInteger min;</p>
<p>NSUInteger max;</p>
<p>// process the data</p>
<p>self.min = min;</p>
<p>self.max = max;</p>
<p>}</p>
<p>@end</p>
<p>int main() {</p>
<p>NSMutableSet *threads = [NSMutableSet set];</p>
<p>NSUInteger numberCount = self.numbers.count;</p>
<p>NSUInteger threadCount = 4;</p>
<p>for (NSUInteger i = 0; i &lt; threadCount; i++) {</p>
<p>NSUInteger offset = (numberCount / threadCount) * i;</p>
<p>NSUInteger count = MIN(numberCount - offset, numberCount / threadCount);</p>
<p>NSRange range = NSMakeRange(offset, count);</p>
<p>NSArray *subset = [self.numbers subarrayWithRange:range];</p>
<p>FindMinMaxThread *thread = [[FindMinMaxThread alloc]<br>initWithNumbers:subset];</p>
<p>[threads addObject:thread];</p>
<p>[thread start];</p>
<p>}</p>
<p>//写一个死循环，直到遍历所有thread.isFinished==YES的时候才break</p>
<p>}</p>
<p>我们得出的结论是无论使用pthread还是NSThread我们都无法优雅的解决多线程同步的问题。虽然使用NSThread的一些方法比如<a target="_blank" rel="noopener" href="https://juejin.im/post/5a66c9b751882573520d8abc">performSelectoer:onThread:</a>会优雅一些，但依然很智障。</p>
<p>使用pthread或者NSThread最直接的问题就是无法控制的线程数量，创建一个线程的开销相对较大，切换线程也有开销，如果无法全局的管理，就会带来线程爆炸的问题。由此提出了线程池的概念，threadpool，GCD就是对线程池的一种封装。</p>
<p>GCD</p>
<p>在下一篇博客详细的介绍GCD的API和细节</p>
<p>GCD使我们不再手动做线程交互</p>
<p>使用Queue代替thread来进行开发，Queue的概念更加纯粹和易用</p>
<p>GCD暴露了5种Queue来使用：</p>
<p>Main</p>
<p>3种不同优先级的background queue</p>
<p>一种低I/O的，比上面四种更低优先级的queue</p>
<p>对于共用资源的不同线程一般不使用不同的优先级，可能会导致一些<a target="_blank" rel="noopener" href="https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/#priority-inversion">低优先级的任务阻塞了高优先级的任务。</a>【优先级反转】</p>
<p>NSOperationQueue</p>
<p>掠过</p>
<p>NSRunLoop</p>
<p>一个runloop一定是绑定着一个线程的</p>
<p>当你发起一个timer，NSURLConnection或者performSlector:withObject:afterDelay:，都是runloop在后台处理着这些事情。</p>
<p>runloop可能工作在不同的mode，每一个mode定义了不同的runloop需要响应的事件。</p>
<p>典型的场景是scroll，scroll的时候，runloop并没有工作在default模式，这时，default模式下的timer就会失效。</p>
<p><strong>并发导致的问题</strong></p>
<p><strong>共享资源的问题：</strong></p>
<p><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Race_conditions#Software">Race condition</a></p>
<p><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Out-of-order_execution">CPU优化带来的乱序执行对读写顺序的改变</a></p>
<p>The key concept of OoOE processing is to allow the processor to avoid a<br>class of stalls that occur when the data needed to perform an operation<br>are unavailable.<br>就是说乱序执行可以在不影响逻辑的情况下更高的命中CPU缓存。</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Tomasulo%E7%AE%97%E6%B3%95"><strong>Tomasulo算法</strong></a></p>
<p><strong>Mutual Exclusion (Mutex) 互斥锁</strong></p>
<p>防止两个线程同时访问一个资源</p>
<p>某一个时刻只有一个线程拥有这个锁</p>
<p>获取资源前先acquire mutex lock</p>
<p>使用完资源，release llock</p>
<p><strong>Mutex lock必须处理CPU指令乱序执行带来的问题</strong> 使用<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/12346487/what-do-each-memory-order-mean"><strong>memory<br>barrier</strong></a></p>
<p>OC大部分的原子特性来自于OSAtomic，底层使用的是std::atomic</p>
<p>注意atomic保证原子性，volidate只标记易变，不能保证原子性</p>
<p>atomic保证单个操作的原子性，但是不能保证两个原子操作之间的顺序，由此引入了memorybarrier</p>
<p><a target="_blank" rel="noopener" href="http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync">一篇来自GCC的关于使用memory_order的解释</a></p>
<p>如果cpu乱序把内存读写放在了mutext<br>lock前，mutex就失效了，所以要使用memory barrier</p>
<p><strong>Dead Lock</strong></p>
<p>void swap(A, B)</p>
<p>{</p>
<p>lock(lockA);</p>
<p>lock(lockB);</p>
<p>int a = A;</p>
<p>int b = B;</p>
<p>A = b;</p>
<p>B = a;</p>
<p>unlock(lockB);</p>
<p>unlock(lockA);</p>
<p>}</p>
<p>一段典型的死锁代码，两个线程分别调用swap(a, b)和swap(b, a)的时候就挂了</p>
<p>需要的共享资源越多，陷入死锁的风险就越大。</p>
<p><strong>Starvation</strong></p>
<p>多读单写问题</p>
<p><strong>优先级反转</strong></p>
<p>一种case：高优和低优的task共享一个资源，低优先级先lock了，它预期是快速释放lock，然后让高优先级的获取到lock，</p>
<p><strong>第二篇博客</strong><br><a target="_blank" rel="noopener" href="https://www.objc.io/issues/2-concurrency/low-level-concurrency-apis/">低级并发API</a></p>
<p><strong>灵活性带来了复杂性和各种职责。</strong></p>
<p><strong>dispatch_async</strong></p>
<p>这个方法和sync方法是GCD的本质，需要认真分析源码</p>
<p><strong>#ifdef</strong> __BLOCKS__</p>
<p><strong>void</strong></p>
<p>dispatch_async(dispatch_queue_t dq, dispatch_block_t work)</p>
<p>{</p>
<p>dispatch_continuation_t dc = _dispatch_continuation_alloc();</p>
<p><strong>uintptr_t</strong> dc_flags = DC_FLAG_CONSUME;</p>
<p>dispatch_qos_t qos;</p>
<p>qos = _dispatch_continuation_init(dc, dq, work, 0, dc_flags);</p>
<p>_dispatch_continuation_async(dq, dc, qos, dc-&gt;dc_flags);</p>
<p>}</p>
<p><strong>#endif</strong></p>
<p>//可以看到这里是创建了一个dispatch_continuation_t的变量，对我们传入的block进行封装</p>
<p>//flag是DC_FLAG_CONSUME</p>
<p>//然后做QOS</p>
<p>//重点在_dispatch_continuation_async</p>
<p>DISPATCH_ALWAYS_INLINE</p>
<p><strong>static</strong> <strong>inline</strong> <strong>void</strong></p>
<p>_dispatch_continuation_async(dispatch_queue_class_t dqu,</p>
<p>dispatch_continuation_t dc, dispatch_qos_t qos, <strong>uintptr_t</strong> dc_flags)</p>
<p>{</p>
<p><strong>#if</strong> DISPATCH_INTROSPECTION</p>
<p><strong>if</strong> (!(dc_flags &amp; DC_FLAG_NO_INTROSPECTION)) {</p>
<p>_dispatch_trace_item_push(dqu, dc);</p>
<p>}</p>
<p><strong>#else</strong></p>
<p>(<strong>void</strong>)dc_flags;</p>
<p><strong>#endif</strong></p>
<p><strong>return</strong> dx_push(dqu._dq, dc, qos);</p>
<p>}</p>
<p>//DISPATCH_INTROSPECTION是个GCC编译环境变量</p>
<p><strong>#define</strong> dx_push(x, y, z) dx_vtable(x)-&gt;dq_push(x, y, z)</p>
<p><strong>#define</strong> dx_vtable(x) (&amp;(x)-&gt;do_vtable-&gt;_os_obj_vtable)</p>
<p>//dx_push实际执行的就是dq_push，dq_push有很多种，见下图：</p>
<p><img src="./gcd/media/image2.png" alt="Generated">{width=”6.041666666666667in”<br>height=”3.5625in”}</p>
<p>无论是lane_push,<br>workloop_push_mgr_push最后都会转发到root_queue_push上去，所谓转发，就是把对象（y）链接到root<br>queue上去，最终在root queue上执行block的代码如下：</p>
<p><strong>static</strong> <strong>inline</strong> <strong>void</strong></p>
<p>_dispatch_root_queue_push_inline(dispatch_queue_global_t dq,</p>
<p>dispatch_object_t _head, dispatch_object_t _tail, <strong>int</strong> n)</p>
<p>{</p>
<p><strong>struct</strong> dispatch_object_s <strong>*</strong>hd = _head._do, *tl = _tail._do;</p>
<p><strong>if</strong> (unlikely(os_mpsc_push_list(os_mpsc(dq, dq_items), hd, tl,<br>do_next))) {</p>
<p><strong>return</strong> _dispatch_root_queue_poke(dq, n, 0);</p>
<p>}</p>
<p>}</p>
<p><strong>void</strong></p>
<p>_dispatch_root_queue_poke(dispatch_queue_global_t dq, <strong>int</strong> n,<br><strong>int</strong> floor)</p>
<p>{</p>
<p><strong>if</strong> (!_dispatch_queue_class_probe(dq)) {</p>
<p><strong>return</strong>;</p>
<p>}</p>
<p><strong>#if</strong> !DISPATCH_USE_INTERNAL_WORKQUEUE</p>
<p><strong>#if</strong> DISPATCH_USE_PTHREAD_POOL</p>
<p><strong>if</strong> (likely(dx_type(dq) == DISPATCH_QUEUE_GLOBAL_ROOT_TYPE))</p>
<p><strong>#endif</strong></p>
<p>{</p>
<p><strong>if</strong> (unlikely(!os_atomic_cmpxchg2o(dq, dgq_pending, 0, n, relaxed)))<br>{</p>
<p>_dispatch_root_queue_debug(&quot;worker thread request still pending &quot;</p>
<p>&quot;for global queue: %p&quot;, dq);</p>
<p><strong>return</strong>;</p>
<p>}</p>
<p>}</p>
<p><strong>#endif</strong> <em>// !DISPATCH_USE_INTERNAL_WORKQUEUE</em></p>
<p><strong>return</strong> _dispatch_root_queue_poke_slow(dq, n, floor);</p>
<p>}</p>
<p>//只有队列的首个任务能触发poke_slow</p>
<p>//注意这里有使用内部workqueue还是pthreadPool的区别，在pokeSlow里</p>
<p>static void</p>
<p>_dispatch_root_queue_poke_slow(dispatch_queue_global_t dq, int n, int<br>floor)</p>
<p>{</p>
<p>int remaining = n;</p>
<p>int r = ENOSYS;</p>
<p>_dispatch_root_queues_init();</p>
<p>_dispatch_debug_root_queue(dq, __func__);</p>
<p>_dispatch_trace_runtime_event(worker_request, dq, (uint64_t)n);</p>
<p>#if !DISPATCH_USE_INTERNAL_WORKQUEUE</p>
<p>#if DISPATCH_USE_PTHREAD_ROOT_QUEUES</p>
<p>if (dx_type(dq) == DISPATCH_QUEUE_GLOBAL_ROOT_TYPE)</p>
<p>#endif</p>
<p>{</p>
<p>_dispatch_root_queue_debug(&quot;requesting new worker thread for global &quot;</p>
<p>&quot;queue: %p&quot;, dq);</p>
<p>r = _pthread_workqueue_addthreads(remaining,</p>
<p>_dispatch_priority_to_pp_prefer_fallback(dq-&gt;dq_priority));</p>
<p>(void)dispatch_assume_zero(r);</p>
<p>return;</p>
<p>}</p>
<p>#endif <em>// !DISPATCH_USE_INTERNAL_WORKQUEUE</em></p>
<p>#if DISPATCH_USE_PTHREAD_POOL</p>
<p>...,</p>
<p>#endif <em>// DISPATCH_USE_PTHREAD_POOL</em></p>
<p>}</p>
<p>//可以看到最后还是使用pthread_workqueue进行了处理，至于pthread是如何处理的，就要深入libpthread进行查看了</p>
<p>很艰难的看了下源码，发现这种底层库的逻辑绝对不是一天两天能看完的，啥是MGR_push，啥是lane_push，main_push是怎么做的，这些内容太多了...需要慢慢研究.…【或者不研究**:(**<br>】</p>
<p><strong>disptach_once</strong></p>
<p>dispatch_once 具有非常高效的检查性能，我们通常用来初始化单例和全局数据。</p>
<p>单例通常带来测试上的难题。</p>
<p>dispatch_once_t<br>类型的数据不能用来作为一个对象的成员，必须是一个static静态量。</p>
<p>本质上应该是封装的pthread_once，但是更好用，更少的错误。</p>
<p><strong>dispatch_after</strong></p>
<p>dispatch_after目前我理解就像是时序中的goto，在前端这种异步场景非常多的情况下意味着竞争和大量的判断条件容错，尽量不要使用。</p>
<p>dispatch_after的block无法直接取消，取消非常麻烦，<a target="_blank" rel="noopener" href="https://mattrajca.com/2016/04/23/canceling-blocks-in-gcd.html">但是还是可以取消的</a></p>
<p><strong>Queues</strong></p>
<p>Concurrent or serial, default serial</p>
<p>GCD维持了一个thread pool，与thread pool交互的就是queue</p>
<p>Thread pool的好处：By maintaining a pool of threads, the model increases<br>performance and avoids latency in execution due to frequent creation and<br>destruction of threads for short-lived tasks</p>
<p>thread是消耗内存和内核资源的，但是比起一个存在的thread消耗的静态资源，创建和销毁的消耗会更大。</p>
<p>如果queue提交到的thread<br>pool里的一个task阻塞了一个thread，这时GCD会创建一个新的thead并加入到线程池中。</p>
<p>task阻塞thread的一种常见场景是I/O或者网络请求（也是IO的一种）</p>
<p>IO场景下，比如网络请求，我们需要维持一个线程一直做阻塞的读取操作，或者不停的查询数据是否返回了。这都不是最佳姿势，kqueue提供了一种最佳姿势，当数据返回的时候抛出一个事件。GCD也是使用了这种方法（使用dispatch_source来作为event）。</p>
<p>_isolation = dispatch_queue_create([[self description] UTF8String],<br>NULL);</p>
<p>_nativeSocket = socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP);</p>
<p>struct sockaddr_in sin = {};</p>
<p>sin.sin_len = sizeof(sin);</p>
<p>sin.sin_family = AF_INET6;</p>
<p>sin.sin_port = htons(port);</p>
<p>sin.sin_addr.s_addr= INADDR_ANY;</p>
<p>int err = bind(result.nativeSocket, (struct sockaddr *) &amp;sin,<br>sizeof(sin));</p>
<p>NSCAssert(0 &lt;= err, @&quot;&quot;);</p>
<p>_eventSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ,<br>_nativeSocket, 0, _isolation);</p>
<p>dispatch_source_set_event_handler(result.eventSource, ^{</p>
<p>acceptConnection(_nativeSocket);</p>
<p>});//使用dispatch_source来完成event的通知</p>
<p><strong>Target Queue</strong></p>
<p>可以为你的创建的queue设置一个target<br>queue，这样就可以创建一条转发chain，这个特性在你使用queue来隔离的时候是非常有用的：</p>
<p>Foo<br>这个队列转发到Bar这个队列上，如果foo是一个隔离队列，转发到bar这个隔离队列上，那么就一定是线程安全的</p>
<p>如果target queue是个serial，那么本身也会被转化为serial</p>
<p><strong>Priorities</strong></p>
<p>大多数情况下，设置priority并不会像你想的那样做，实际上有非常多的问题，比如优先级反转问题。</p>
<p><strong>Isolation</strong></p>
<p>隔离是常见的GCD queue的使用方式，有两种变体。</p>
<p>保护资源</p>
<p>任何时刻只有一个线程允许操作这个资源。</p>
<p>单一资源，多读单写</p>
<p>- (void)setCount:(NSUInteger)count forKey:(NSString *)key</p>
<p>{</p>
<p>key = [key copy];</p>
<p>dispatch_barrier_async(self.isolationQueue, ^(){</p>
<p>if (count == 0) {</p>
<p>[self.counts removeObjectForKey:key];</p>
<p>} else {</p>
<p>self.counts[key] = @(count);</p>
<p>}</p>
<p>});</p>
<p>}</p>
<p>- (NSUInteger)countForKey:(NSString *)key;</p>
<p>{</p>
<p>__block NSUInteger count;</p>
<p>dispatch_sync(self.isolationQueue, ^(){</p>
<p>NSNumber *n = self.counts[key];</p>
<p>count = [n unsignedIntegerValue];</p>
<p>});</p>
<p>return count;</p>
<p>}</p>
<p>isolationQueue是一个concurrent的。</p>
<p>When you use concurrent queues, make sure that all <em>barrier</em> calls are<br><em>async</em></p>
<p>使用并发队列的时候，barrier必须是async的，否则<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/37341738/dead-lock-with-dispatch-barrier">可能会死锁。</a></p>
<p><strong>Group</strong></p>
<p>group是一个我们非常常用的API，我们把所有的API都丢出来讲一下</p>
<p>Group主要解决的是多个异步任务ABCD我们不确定谁先返回，但是需要等待ABCD全部返回才可以继续进行某个流程。这个在RAC里可以使用ZIP或者lift_select来完成等待多个信号量的操作。而GCD在底层上，使用的是一个dispatch_group_t的结构体，里面存放了一个value，每一次enter/leave的时候我们就会对这个value进行操作，当value降为0的时候(某一次leave的时候)我们就notify。</p>
<p>group的所有API都在sema4.c里，因为group实质上就是一个sema4.</p>
<p>在老版本的dispatch里，还没有dispatch_object这样的概念，可以参考博文5.</p>
<p>dispatch_group_create(<strong>void</strong>);</p>
<p>内部是_dispatch_group_create_with_count(0)</p>
<p>创建一个dispatch_group_t的对象</p>
<p>atomic的把-0这个value赋值到对象的flag（dg_bits）里</p>
<p>使用-0的原因是这个value每次enter的时候是sub一次，leave的时候add一次，所以create_with_count(n)的逻辑是-n</p>
<p>dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue,<br>dispatch_block_t block);</p>
<p>给一个group提交一个block，异步执行</p>
<p>创建一个dispatch_continuation_t， init</p>
<p>用_dispatch_continuation_group_async把这个新的block派发出去</p>
<p>_dispatch_continuation_group_async</p>
<p>dispatch_group_enter</p>
<p>_dispatch_continuation_async</p>
<p>dispatch_group_async_f(dispatch_group_t group, dispatch_queue_t queue,<br><strong>void</strong> *_Nullable context, dispatch_function_t work);</p>
<p>给一个group提交一个函数，异步执行</p>
<p>dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout);</p>
<p>同步的等待到所有的异步block执行完毕或者time out</p>
<p>如果group没有block提交进去的话则直接返回</p>
<p>内部实现：</p>
<p>os_atomic_rmw_loop2o一个rmw的循环等着，这个我们在notify里也会遇到</p>
<p>遇到结束条件的时候循环结束，进入_dispatch_group_wait_slow</p>
<p>里面又是一堆东西，感觉是各种兜底和异常处理</p>
<p>dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue,<br>dispatch_block_t block);</p>
<p>所有提交给group的block被执行完毕的时候会触发这个block</p>
<p>内部逻辑，使用了一个<br>dispatch_continuation_t类型的变量，它会把需要执行的block持有住。</p>
<p>根据目前的版本看，感觉陷入了一个使用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Read-modify-write">rmw</a>的循环不停的查询这个group是不是完成了，如果是，就执行_dispatch_group_wake</p>
<p>_dispatch_group_wake:<br>执行一系列的continuation（一个链表）前，先snapshoot一下：</p>
<p>dc = os_mpsc_capture_snapshot(os_mpsc(dg, dg_notify), &amp;tail);</p>
<p><em>// Snapshot before anything is notified/woken<br>&lt;rdar://problem/8554546&gt;</em></p>
<p>使用_dispatch_continuation_async对所有的continuation的block进行处理</p>
<p>这里标红是因为想不明白为什么会写一个循环。。。循环终止的条件就是这个group的flag变了，可以notify了，感觉性能低下，还会有延迟</p>
<p>dispatch_group_notify_f(dispatch_group_t group, dispatch_queue_t queue,<br><strong>void</strong> *_Nullable context, dispatch_function_t work);</p>
<p>dispatch_group_enter(dispatch_group_t group);</p>
<p>按照之前说的，对dg_bits的value字段做-1操作</p>
<p>判断是否溢出到MAX，如果是，则crash</p>
<p>dispatch_group_leave(dispatch_group_t group);</p>
<p>group的dg_bits生成两个新的变量，old_state和new_state</p>
<p>按照之前说的，对old_state的value字段做+1操作，</p>
<p>与enter单纯的-1逻辑不同，+1因为有可能到0，需要处理多种情况和线程被打断的情况</p>
<p>Do:</p>
<p>new_state=old_state</p>
<p><strong>if</strong> ((old_state &amp; DISPATCH_GROUP_VALUE_MASK) == 0) {</p>
<p>new_state &amp;= ~DISPATCH_GROUP_HAS_WAITERS;</p>
<p>new_state &amp;= ~DISPATCH_GROUP_HAS_NOTIFS;</p>
<p>} <strong>else</strong> {</p>
<p><em>// If the group was entered again since the atomic_add above,</em></p>
<p><em>// we can&#39;t clear the waiters bit anymore as we don&#39;t know for</em></p>
<p><em>// which generation the waiters are for</em></p>
<p>new_state &amp;= ~DISPATCH_GROUP_HAS_NOTIFS;</p>
<p>}</p>
<p><strong>if</strong> (old_state == new_state) <strong>break</strong>;</p>
<p>While new和old无change</p>
<p>然后_dispatch_group_wake(dg, old_state, <strong>true</strong>);</p>
<p>这段代码着实比较难理解...可以自行理解一下，之所以写了伪代码是免去二次查阅gcc<br>built_in function的麻烦...</p>
<p><strong>Source</strong></p>
<p>dispatch_source_t是一个非常底层的东西，下面介绍一些用途，但是iOS上使用有限，因为你并不能唤醒一个process，所以不能watch<br>it，并且你并不能往app bundle外读写文件，所以并不能watch file。</p>
<p>它实际上是BSD内核里常用的kqueue的封装</p>
<p>source支持的event【实际上就是kqueue支持的事情】：</p>
<p>Mach port send right state changes.</p>
<p>Mach port receive right state changes.</p>
<p>External process state change.</p>
<p>File descriptor ready for read.</p>
<p>File descriptor ready for write.</p>
<p>Filesystem node event.</p>
<p>POSIX signal.</p>
<p>Custom timer.</p>
<p>Custom event.<br>重点解释一下啥是自定义事件，简单说就是自己给自己发信号，用dispatch_source_merge_data函数。为什么叫这个奇怪的名字呢？因为GCD会在触发event对应的handler前自动合并多个事件，你可以调用多次dispatch_source_merge_data。</p>
<p><strong>#define</strong> DISPATCH_SOURCE_TYPE_DATA_ADD<br>(&amp;_dispatch_source_type_data_add)</p>
<p><strong>#define</strong> DISPATCH_SOURCE_TYPE_DATA_OR<br>(&amp;_dispatch_source_type_data_or)</p>
<p><strong>#define</strong> DISPATCH_SOURCE_TYPE_DATA_REPLACE<br>(&amp;_dispatch_source_type_data_replace)</p>
<p><strong>void</strong> dispatch_source_merge_data(dispatch_source_t source,<br><strong>uintptr_t</strong> value);</p>
<p>一个自定义的event有一个data属性，可以使用上述函数对一些系统行为的data进行处理，在handler回调的时候使用dispatch_source_get_data就可以获取到合并（替换）后的data了。</p>
<p>场景举例子：</p>
<p>如果一个异步线程需要更新一个进度条，因为主线程带有很多的事件发送过去，最好的办法就是把我们的数据merge进去一块发送过去。</p>
<p>dispatch_source_t source =<br>dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0,<br>dispatch_get_main_queue());</p>
<p>dispatch_source_set_event_handler(source, ^{</p>
<p>[progressIndicator incrementBy:dispatch_source_get_data(source)];</p>
<p>});</p>
<p>dispatch_resume(source);</p>
<p>dispatch_apply([array count], globalQueue, ^(size_t index) {</p>
<p>// do some work on data at index</p>
<p>dispatch_source_merge_data(source, 1);</p>
<p>});</p>
<p>注意：dispatch_source_t创建出来以后永远都是处于suspended状态，必须要手动resume。</p>
<p>但是实际上在考虑要不要使用source的时候，只要问一个问题就好了，你希望你的event被合并吗？如果不希望，就是用dispatch_async，使用dispatch_async，你的动作块一定会被触发。但是如果使用source，它会在主线程忙碌的时候合并，不论触发多少次，handler只会触发一次。</p>
<p>下面几个其实都是使用系统内置的事件</p>
<p>dispatch_queue_t globalQueue =<br>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</p>
<p>dispatch_source_t stdinSource =<br>dispatch_source_create(DISPATCH_SOURCE_TYPE_READ,STDIN_FILENO,0,globalQueue);</p>
<p>dispatch_source_set_event_handler(stdinSource, ^{</p>
<p>char buf[1024];</p>
<p>int len = read(STDIN_FILENO, buf, sizeof(buf));</p>
<p>if(len &gt; 0)</p>
<p>NSLog(@&quot;Got data from stdin: %.*s&quot;, len, buf);</p>
<p>});</p>
<p>dispatch_resume(stdinSource);</p>
<p>这样处理的最大的优点是我们是基于unix处理的，而不是runloop，而且如果你使用的c标准的read，你会需要处理意外情况，但是GCD处理了这些东西，只有正常的时候你的handler才会被触发。</p>
<p><strong>观察进程的生命周期</strong></p>
<p>如果有一个进程在运行，并且你需要知道它啥时候结束的，GCD可以做这件事情，并且你可以用它去检查这个进程什么时候进行了fork，也就是又起了一个子进程或者一个signal被发送到了这个进程里。</p>
<p>@import AppKit;</p>
<p>// ...</p>
<p>NSArray *array = [NSRunningApplication</p>
<p>runningApplicationsWithBundleIdentifier:@&quot;com.apple.mail&quot;];</p>
<p>if (array == nil || [array count] == 0) {</p>
<p>return;</p>
<p>}</p>
<p>pid_t const pid = [[array firstObject] processIdentifier];</p>
<p>self.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_PROC, pid,</p>
<p>DISPATCH_PROC_EXIT, DISPATCH_TARGET_QUEUE_DEFAULT);</p>
<p>dispatch_source_set_event_handler(self.source, ^(){</p>
<p>NSLog(@&quot;Mail quit.&quot;);</p>
<p>// If you would like continue watching for the app to quit,</p>
<p>// you should cancel this source with dispatch_source_cancel and create<br>new one</p>
<p>// as with next run app will have another process identifier.</p>
<p>});</p>
<p>dispatch_resume(self.source);</p>
<p>上面的代码会监控mail这个进程，打印mail quit当它退出的时候</p>
<p><strong>监控文件</strong></p>
<p>你可以直接使用dispatch_source_t对一个文件进行监控，如果它被修改，就会触发事件对应的handler</p>
<p>NSURL *directoryURL; // assume this is set to a directory</p>
<p>int const fd = open([[directoryURL path] fileSystemRepresentation],<br>O_EVTONLY);</p>
<p>if (fd &lt; 0) {</p>
<p>char buffer[80];</p>
<p>strerror_r(errno, buffer, sizeof(buffer));</p>
<p>NSLog(@&quot;Unable to open \&quot;%@\&quot;: %s (%d)&quot;, [directoryURL path],<br>buffer, errno);</p>
<p>return;</p>
<p>}</p>
<p>dispatch_source_t source =<br>dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fd,</p>
<p>DISPATCH_VNODE_WRITE | DISPATCH_VNODE_DELETE,<br>DISPATCH_TARGET_QUEUE_DEFAULT);</p>
<p>dispatch_source_set_event_handler(source, ^(){</p>
<p>unsigned long const data = dispatch_source_get_data(source);</p>
<p>if (data &amp; DISPATCH_VNODE_WRITE) {</p>
<p>NSLog(@&quot;The directory changed.&quot;);</p>
<p>}</p>
<p>if (data &amp; DISPATCH_VNODE_DELETE) {</p>
<p>NSLog(@&quot;The directory has been deleted.&quot;);</p>
<p>}</p>
<p>});</p>
<p>dispatch_source_set_cancel_handler(source, ^(){</p>
<p>//为什么要设置这个东西呢？不管你在读还是写，如果另一个file<br>descriptor在我们的source还active的时候创建了，并且拥有相同的number，你的source会读取到一些并不是它想要的东西，所以这种时候我们就关闭好了。</p>
<p>close(fd);</p>
<p>});</p>
<p>self.source = source;</p>
<p>dispatch_resume(self.source);</p>
<p><strong>Timer</strong></p>
<p>大多数情况下，NSTimer都是定时器的首选，但是基于GCD的定时器则更加灵活。</p>
<p>需要注意的是需要对GCD的timer进行冗余控制，这会节约电量。</p>
<p>dispatch_source_t source =<br>dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,</p>
<p>0, 0, DISPATCH_TARGET_QUEUE_DEFAULT);</p>
<p>dispatch_source_set_event_handler(source, ^(){</p>
<p>NSLog(@&quot;Time flies.&quot;);</p>
<p>});</p>
<p>dispatch_source_set_timer(source, DISPATCH_TIME_NOW, 5ull *<br>NSEC_PER_SEC,</p>
<p>100ull * NSEC_PER_MSEC);</p>
<p>self.source = source;</p>
<p>dispatch_resume(self.source);</p>
<p><strong>可以取消</strong></p>
<p>可以给dispatch_source创建一个cancel<br>handler，在这个source被取消的时候触发。</p>
<p>底层实现:</p>
<p><strong>void</strong> dispatch_block_cancel(dispatch_block_t db)</p>
<p>{</p>
<p>dispatch_block_private_data_t dbpd = _dispatch_block_get_data(db);</p>
<p><strong>if</strong> (unlikely(!dbpd)) {</p>
<p>DISPATCH_CLIENT_CRASH(0, &quot;Invalid block object passed to &quot;</p>
<p>&quot;dispatch_block_cancel()&quot;);</p>
<p>}</p>
<p>(<strong>void</strong>)os_atomic_or2o(dbpd, dbpd_atomic_flags, DBF_CANCELED,<br>relaxed);</p>
<p>}</p>
<p>os_atomic_or2o宏展开后</p>
<p>(void)({<br>__typeof__(__c11_atomic_load(((__typeof__(*((&amp;(dbpd)-&gt;dbpd_atomic_flags)))<br>_Atomic *)((&amp;(dbpd)-&gt;dbpd_atomic_flags))), memory_order_relaxed)) _v<br>= (((1u))), _r =<br>__c11_atomic_fetch_or(((__typeof__(*((&amp;(dbpd)-&gt;dbpd_atomic_flags)))<br>_Atomic *)((&amp;(dbpd)-&gt;dbpd_atomic_flags))), _v,<br>memory_order_relaxed); (__typeof__(_r))(_r | _v); });</p>
<p>__c11_atomic_fetch_or 这个函数会set dbpd的dbpd_atomic_flags</p>
<p><strong>GCD data buffer</strong></p>
<p>GCD有一个dispatch_data_t类型，某种意义上跟NSData<br>很像，但是更加通用一些。</p>
<p>dispatch_data_t类型是可以被retain或者release的，看起来这没啥独特的，但是需要在C<br>API下，我们只能用过malloc或者开辟栈上的地址来获取缓存，这些都没有归属关系ownership。</p>
<p>dispatch_data_t可以由两个不连续的地址拼接起来</p>
<p>dispatch_data_t a; // Assume this hold some valid data</p>
<p>dispatch_data_t b; // Assume this hold some valid data</p>
<p>dispatch_data_t c = dispatch_data_create_concat(a, b);</p>
<p>//需要注意c并不是a和b连起来以后的copy，c只是简单的retain了a和b，然后我们就可以遍历c表达的内存了，会自动的按照a，b的顺序遍历。</p>
<p>dispatch_data_apply(c, ^bool(dispatch_data_t region, size_t offset,<br>const void *buffer, size_t size) {</p>
<p>fprintf(stderr, &quot;region with offset %zu, size %zu\n&quot;, offset, size);</p>
<p>return true;</p>
<p>});</p>
<p>//甚至可以使用dispatch_data_create_subrange这种假装数据是完整的操作</p>
<p>dispatch_data_t有大量的问题问<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/9152851/how-to-convert-dispatch-data-t-to-nsdata">怎么转成NSData。</a></p>
<p>dispatch_data_t是配合GCD维护数据的好帮手，<a target="_blank" rel="noopener" href="https://github.com/facebook/SocketRocket/blob/0a023409b138039d1ab5ac5431fe61c5f334e86b/SocketRocket/SRWebSocket.m">SocketRocket</a>中使用了这一特性【顺便学习一下webSocket还是很不错的】</p>
<p><strong>读写</strong></p>
<p>这里就略过吧，还是使用NSFileHandler或者NSFileManager方便。</p>
<p><strong>原子操作</strong></p>
<p>后面部分我们会分析一下&lt;libkern/OSAtomic.c&gt;中的各种实现</p>
<p>OSAtomicIncrement</p>
<p>OSAtomicDecrement</p>
<p>OSAtomicOr</p>
<p>OSAtomicAnd</p>
<p>OSAtomicXor</p>
<p>OSAtomicTest</p>
<p>上述函数可以用来并发的执行逻辑运算而不需要进行加锁操作，以最高效的方式访问临界资源。</p>
<p>OSAtomicCompareAndSwap</p>
<p>用来做无锁的懒初始化</p>
<p>void * sharedBuffer(void)</p>
<p>{</p>
<p>static void * buffer;</p>
<p>if (buffer == NULL) {</p>
<p>void * newBuffer = calloc(1, 1024);</p>
<p>if (!OSAtomicCompareAndSwapPtrBarrier(NULL, newBuffer, &amp;buffer)) {</p>
<p>free(newBuffer);</p>
<p>}</p>
<p>}</p>
<p>return buffer;</p>
<p>}</p>
<p>OSAtomicEnqueue()</p>
<p>OSAtomicDequeue()</p>
<p>上述两个可以实现LIFO队列，但是还提供了OSAtomicFifoEnqueue()<br>OSAtomicFifoDequeue()</p>
<p>OSSpinLock</p>
<p>自旋锁，通常情况下做性能优化用，但是仍然需要先测量，再优化</p>
<p>但是这个已经被deprecated了，要使用os_unfair_lock_lock或者dispatch_semaphore或者pthread_mutex</p>
<p>网上有很多论述OSSpinLock不再安全的文章自行查阅，主要来自__weak使用了私有API，可能出现优先级反转的问题。</p>
<p><strong>白皮书</strong></p>
<p>新版的没有白皮书，直接看代码吧</p>
<p><strong>&lt;dispatch/object.h&gt;</strong></p>
<p><em>typedef <strong>dispatch_block_t</strong></em></p>
<p>Void <strong>dispatch_retain</strong>(dispatch_object_t object);</p>
<p>Void <strong>dispatch_release</strong>(dispatch_object_t object);</p>
<p>void *_Nullable <strong>dispatch_get_context</strong>(dispatch_object_t object);</p>
<p>Void <strong>dispatch_set_context</strong>(dispatch_object_t object, void<br>*_Nullable context);</p>
<p>Void <strong>dispatch_set_finalizer_f</strong>(dispatch_object_t object,<br>dispatch_function_t _Nullable finalizer);</p>
<p>一个finalizer会在一个dispatch_object销毁（referrence为0）的时候触发</p>
<p>Void <strong>dispatch_activate</strong>(dispatch_object_t object);</p>
<p>Void <strong>dispatch_suspend</strong>(dispatch_object_t object);</p>
<p>Void <strong>dispatch_resume</strong>(dispatch_object_t object);</p>
<p>Void <strong>dispatch_wait</strong>(void *object, dispatch_time_t timeout);</p>
<p>一个generic 函数，被分发到:</p>
<p>dispatch_block_wait</p>
<p>dispatch_group_wait</p>
<p>dispatch_semaphore_wait</p>
<p>取决于第一个参数的类型</p>
<p><strong>dispatch_notify</strong>(void *object, dispatch_object_t queue,<br>dispatch_block_t notification_block);</p>
<p>跟dispatch_wait一样，generic函数，分发到：</p>
<p>dispatch_block_notify</p>
<p>dispatch_group_notify</p>
<p><strong>dispatch_cancel</strong>(void *object);</p>
<p>跟上面一样，分发:</p>
<p>dispatch_block_cancel</p>
<p>dispatch_source_cancel</p>
<p><strong>dispatch_testcancel</strong></p>
<p>跟上面一样，分发：</p>
<p>dispatch_block_testcancel</p>
<p>dispatch_source_testcancel</p>
<p><strong>&lt;dispatch/base.h&gt;</strong></p>
<p>没有啥实际的东西</p>
<p><strong>&lt;dispatch/time.h&gt;</strong></p>
<p>dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta);</p>
<p><strong>&lt;dispatch/queue.h&gt;</strong></p>
<p>dispatch_queue_t</p>
<p>GCD提供了线性的FIFO队列</p>
<p>提交到queue的block会被一个系统管理的thread pool invoke</p>
<p>可以保证一个FIFO队列一次只有一个block被提交上去执行了</p>
<p>dispatch_queue_global_t</p>
<p>对系统thread pool的抽象</p>
<p>是一个共享资源</p>
<p>dispatch_queue_serial_t</p>
<p>一个serial queue某个时刻只会有一个work item执行</p>
<p>不同的serial queue相互之间可能是并发的</p>
<p>dispatch_queue_main_t</p>
<p>为了在主线程上触发，使用这三种方式：dispatch_main(),<br>NSApplicationMain(), or use a CFRunLoop on the main thread</p>
<p>不可被修改，即dispatch_suspend(), dispatch_resume(),<br>dispatch_set_context()这些会失效</p>
<p>dispatch_queue_concurrent</p>
<p>并发队列</p>
<p>可以接受普通的work item和barrier work item</p>
<p><strong>dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</strong></p>
<p>always return immediately</p>
<p>Block一定是NonNull，passing NULL in this parameter is undefined</p>
<p>dispatch_async_f(dispatch_queue_t queue, void *_Nullable context,<br>dispatch_function_t work);</p>
<p>function is submitted</p>
<p>typedef void (*dispatch_function_t)(void *_Nullable);</p>
<p><strong>dispatch_sync(dispatch_queue_t queue, DISPATCH_NOESCAPE<br>dispatch_block_t block);</strong></p>
<p>block被执行完毕后才会返回</p>
<p>被提交的work item并不会观察被提交到的queue的属性，比如QOS或者autorelease<br>frequency</p>
<p><strong>dispatch_sync_f(dispatch_queue_t queue, void *_Nullable context,<br>dispatch_function_t work);</strong></p>
<p>函数执行完毕后才会返回</p>
<p><strong>dispatch_apply</strong>(size_t iterations, dispatch_queue_t，<br>DISPATCH_APPLY_QUEUE_ARG_NULLABILITY queue, DISPATCH_NOESCAPE void<br>(^block)(size_t));</p>
<p>多次（iterations次）提交一个block到queue上去并发执行</p>
<p>block必须可重入</p>
<p>dispatch_apply_f(size_t iterations,dispatch_queue_t<br>DISPATCH_APPLY_QUEUE_ARG_NULLABILITY queue,void *_Nullable context,<br>void (*work)(void *_Nullable, size_t));</p>
<p>前面的figure版</p>
<p>dispatch_queue_t <strong>dispatch_get_current_queue</strong>(void);</p>
<p>block内获得queue，通常用于debug</p>
<p>dispatch_queue_main_t <strong>dispatch_queue_main_t<br>dispatch_get_main_queue</strong>(void)</p>
<p>获得main queue</p>
<p>dispatch_queue_global_t <strong>dispatch_get_global_queue</strong>(intptr_t<br>identifier, uintptr_t flags);</p>
<p>flag这个参数只能传0</p>
<p>queue的priority和QOS等级的map</p>
<p><img src="./gcd/media/image3.png" alt="Generated">{width=”6.041666666666667in”<br>height=”1.2916666666666667in”}</p>
<p>#define DISPATCH_QUEUE_CONCURRENT_INACTIVE \<br>dispatch_queue_attr_make_initially_inactive(DISPATCH_QUEUE_CONCURRENT)</p>
<p>@avaliable 10.0</p>
<p>用来初始化queue的attr，这里是创建一个并发且初始inactive的queue</p>
<p>#define DISPATCH_QUEUE_SERIAL_WITH_AUTORELEASE_POOL \<br>dispatch_queue_attr_make_with_autorelease_frequency(\<br>DISPATCH_QUEUE_SERIAL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM)</p>
<p>@avaliable 10.0</p>
<p>创建一个串行，带autorelease pool的队列</p>
<p>dispatch_queue_attr_t<br><strong>dispatch_queue_attr_make_with_qos_class</strong>(dispatch_queue_attr_t<br>_Nullable attr, dispatch_qos_class_t qos_class, int relative_priority);</p>
<p>@avaliable 8</p>
<p>使用QOS类型来创建dispatch queue attr</p>
<p><strong>dispatch_queue_get_qos_class</strong>(dispatch_queue_t queue, int<br>*_Nullable relative_priority_ptr);</p>
<p>获取创建queue的时候用的QOS</p>
<p><strong>dispatch_queue_create</strong>(const char *_Nullable label,<br>dispatch_queue_attr_t _Nullable attr);</p>
<p><strong>dispatch_queue_create_with_target</strong>(const char *_Nullable label,<br>dispatch_queue_attr_t _Nullable attr, dispatch_queue_t _Nullable<br>target) DISPATCH_ALIAS_V2(dispatch_queue_create_with_target);</p>
<p>@avaliable 8</p>
<p><strong>dispatch_set_target_queue</strong></p>
<p>一个queue的target<br>queue负责实际的处理block的任务，如果没有QOS对象或者相对优先级的时候，那么他的QOS继承自他的target<br>queue</p>
<p>dispatch_get_global_queue()可能会被用来获取target<br>queue，但是推荐的做法是使用dispatch_queue_attr_make_with_qos_class()</p>
<p>如果一个串行队列A的target queue是个串行队列C，串行队列B的target<br>queue也是串行队列C，那么A和B不是并发的，是交替执行的，但是顺序就不知道了</p>
<p>一个dispatch_source的target queue是这个source的handler被触发的queue</p>
<p>一个dispatch_IO_channel的target<br>queue是IO操作执行的queue，如果又IO竞争出现，并且queue的priority设置为了background，那么dispatch_io_read()<br>or dispatch_io_write()会被压制，来减轻IO竞争</p>
<p>对于其他的dispatch object来说，target<br>queue唯一的功能就是决定finalizer在哪里被调用。</p>
<p>改变target queue是异步的，不会立刻生效，已经关联的block不会被修正过来。</p>
<p>如果一个已经被activate的对象被改变了target queue，线程会崩溃。</p>
<p>如果一个queue已经被active并且作为其他人的target<br>queue，那么改变这个queue的target queue的结果是不确定的</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/210d2e867782"><strong>dispatch_main()</strong></a></p>
<p>阻塞主线程，把主线程中已提交的block放到别的线程去执行</p>
<p>这里需要深刻理解一下main queue和main thread之间的区别和联系</p>
<p><strong>dispatch_after</strong>(dispatch_time_t when, dispatch_queue_t queue,<br>dispatch_block_t block);</p>
<p>最常用的代码，用这个的50%是辣鸡代码</p>
<p>内部实现是用一个dispatch_source实现的，但是：</p>
<p><img src="./gcd/media/image4.png" alt="Generated">{width=”6.041666666666667in”<br>height=”4.145833333333333in”}</p>
<p>显然被diss了，但是也没看到有啥解决办法～</p>
<p><strong>dispatch_after_f</strong></p>
<p><strong>dispatch_barrier_async</strong></p>
<p>显然我们已经了解到，所谓的queue，跟并发的执行其实并没有鸟球关系，所谓的并发执行，其实就是每submit<br>一个block到queue的时候，target<br>queue是一个并发的队列，会把我们的block根据QOS立刻派发到某个新的_pthread_workqueue_addthreads出来的thread或者已经存在的老得thread上。那么barrier这个概念就很好实现了。一个异步的queue，在接收到barrier前，一直往target<br>queue上丢block就完了，一旦接收到barrier，就停止丢，开始把后面的block收起来，等到前面的block执行完了，再发送后面的就可以了。</p>
<p>前面的block执行完毕这个是通过semaphore实现的</p>
<p>dispatch_barrier_async_f(dispatch_queue_t queue, void *_Nullable<br>context, dispatch_function_t work);</p>
<p>上面的函数版</p>
<p>dispatch_barrier_sync(dispatch_queue_t queue, DISPATCH_NOESCAPE<br>dispatch_block_t block);</p>
<p>上面的sync版，一般不使用</p>
<p>dispatch_queue_set_specific(dispatch_queue_t queue, const void *key,<br>void *_Nullable context, dispatch_function_t _Nullable destructor);</p>
<p>允许对这个queue设置自己的context，不会有共享问题竞争问题，block在执行的时候也可以获取到。</p>
<p>目前唯一想到的就是debug挺好使的</p>
<p>dispatch_queue_get_specific(dispatch_queue_t queue, const void *key);</p>
<p>上面的getter</p>
<p>dispatch_get_specific(const void *key);</p>
<p>block中调用的时候，返回来的是当前queue对应的key对应的value</p>
<p><strong>&lt;dispatch/block.h&gt;</strong></p>
<p><img src="./gcd/media/image5.png" alt="Generated">{width=”4.5625in” height=”3.625in”}</p>
<p><strong>&lt;dispatch/source.h&gt;</strong></p>
<p>Dispatch source我们在前面比较详细的总结过了，这里就不赘述了</p>
<p><strong>&lt;dispatch/group.h&gt;</strong></p>
<p><img src="./gcd/media/image6.png" alt="Generated">{width=”4.5in” height=”3.75in”}</p>
<p><strong>&lt;dispatch/semaphore.h&gt;</strong></p>
<p><img src="./gcd/media/image7.png" alt="Generated">{width=”5.229166666666667in”<br>height=”2.0416666666666665in”}</p>
<p>Semaphore在之前的版本作为group的底层支持，需要单独讲一下</p>
<p>先说结构：</p>
<p>struct dispatch_semaphore_s {</p>
<p>DISPATCH_OBJECT_HEADER(semaphore);</p>
<p>intptr_t volatile dsema_value;</p>
<p>intptr_t dsema_orig;</p>
<p>_dispatch_sema4_t dsema_sema;</p>
<p>};</p>
<p><strong>dispatch_semaphore_create</strong></p>
<p>不能用低于0的数初始化</p>
<p>有了dispatch_obj以后，用value赋值一下dsema_value</p>
<p>初始化object初始化完后需要调用sem_init这个POSIX方法来初始化dsema_sema，完成的是sema4的注册估计是</p>
<p>intptr_t <strong>dispatch_semaphore_wait</strong>(dispatch_semaphore_t dsema,<br>dispatch_time_t timeout);</p>
<p>Wait (decrement) for a semaphore</p>
<p>如果减一以后的value低于0，这个函数会阻塞线程直到有一个signal把value+1.</p>
<p>intptr_t <strong>dispatch_semaphore_signal</strong>(dispatch_semaphore_t dsema);</p>
<p>Signal (increment) a semaphore.</p>
<p>如果+1前的数值小于0，则唤醒一个wait的thread</p>
<p><strong>_dispatch_semaphore_dispose(dispatch_object_t dou, DISPATCH_UNUSED<br>bool *allow_free) 存在于sema4_internal.h中，暴露给其他模块内部使用</strong></p>
<p>由于dispatch_object均持有一个sema4，所以入参是dispatch_object</p>
<p>由于semaphore是注册到内核中的，需要调用POSIX方法进行销毁<br>semaphore_destroy</p>
<p><strong>&lt;dispatch/once.h&gt;</strong></p>
<p><img src="./gcd/media/image8.png" alt="Generated">{width=”4.833333333333333in”<br>height=”5.270833333333333in”}</p>
<p><strong>&lt;dispatch/data.h&gt;</strong></p>
<p>用不太上，只有socketRocket见过</p>
<p><strong>&lt;dispatch/io.h&gt;</strong></p>
<p>用不太上</p>
<p><strong>加餐</strong></p>
<p>GCD显然经过了一次OOP的大重构，整体结构跟一些17年的文章已经对不上号了。</p>
<p>定义了dispatch_object_t</p>
<p>typedef union {</p>
<p>struct _os_object_s *_os_obj;</p>
<p>struct dispatch_object_s *_do;</p>
<p>struct dispatch_queue_s *_dq;</p>
<p>struct dispatch_queue_attr_s *_dqa;</p>
<p>struct dispatch_group_s *_dg;</p>
<p>struct dispatch_source_s *_ds;</p>
<p>struct dispatch_mach_s *_dm;</p>
<p>struct dispatch_mach_msg_s *_dmsg;</p>
<p>struct dispatch_semaphore_s *_dsema;</p>
<p>struct dispatch_data_s *_ddata;</p>
<p>struct dispatch_io_s *_dchannel;</p>
<p>} dispatch_object_t DISPATCH_TRANSPARENT_UNION;</p>
<p>以semaphore创建为例</p>
<p>dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)</p>
<p>{</p>
<p>dispatch_semaphore_t dsema;</p>
<p>// If the internal value is negative, then the absolute of the value is</p>
<p>// equal to the number of waiting threads. Therefore it is bogus to</p>
<p>// initialize the semaphore with a negative value.</p>
<p>if (value &lt; 0) {</p>
<p>return DISPATCH_BAD_INPUT;</p>
<p>}</p>
<p>dsema = _dispatch_object_alloc(DISPATCH_VTABLE(semaphore),</p>
<p>sizeof(struct dispatch_semaphore_s));</p>
<p>//我们先创建一个dsema的dispatch_semaphore_s结构体，dispatch_semaphore_t就是dispatch_semaphore_s，但是这里的逻辑真的很奇怪，从size来看我们取到的是一个dispatch_semaphore_s大小的结构体，就是一个dispatch_semaphore_t，但是接下来我们直接把拿这个玩意当dispatch_object来用了原因看下面semaphore_s的定义可以知道，声明了一个DISPATCH_OBJECT_HEADER，这个实际上封装了很多object共有的属性，比如用于链表的next，用于转发的targetq</p>
<p>dsema-&gt;do_next = DISPATCH_OBJECT_LISTLESS;</p>
<p>dsema-&gt;do_targetq = _dispatch_get_default_queue(false);</p>
<p>dsema-&gt;dsema_value = value;</p>
<p>_dispatch_sema4_init(&amp;dsema-&gt;dsema_sema, _DSEMA4_POLICY_FIFO);</p>
<p>dsema-&gt;dsema_orig = value;</p>
<p>return dsema;</p>
<p>}</p>
<p>//dispatch_semaphore_s的定义如下</p>
<p>struct dispatch_semaphore_s {</p>
<p>DISPATCH_OBJECT_HEADER(semaphore);</p>
<p>//header中封装了一个object，起这个名字显然大部分我们使用的具体的结构体，其实都封装了一个dispatch_object在里面</p>
<p>intptr_t volatile dsema_value;</p>
<p>intptr_t dsema_orig;</p>
<p>_dispatch_sema4_t dsema_sema;</p>
<p>};</p>
<p>typedef struct dispatch_continuation_s *dispatch_continuation_t;</p>
<p>typedef struct dispatch_queue_s *dispatch_queue_t;</p>
<p>typedef struct dispatch_source_s *dispatch_source_t;</p>
<p>typedef struct dispatch_group_s *dispatch_group_t;</p>
<p>typedef struct dispatch_object_s *dispatch_object_t;</p>
<p><strong>Pthread in XNU</strong></p>
<p>学习一下libpthread project</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/master/bsd/pthread/pthread_workqueue.c"><strong>主要学习QOS的解决方案</strong></a></p>
<p><strong>第三篇博客</strong><br><a target="_blank" rel="noopener" href="https://www.objc.io/issues/2-concurrency/thread-safe-class-design/">设计线程安全的类</a></p>
<p>UIKit非线程安全</p>
<p>时刻注意死锁</p>
<p>避免使用@synchronize</p>
<p><strong>第四篇博客</strong><br><a target="_blank" rel="noopener" href="https://www.objc.io/issues/2-concurrency/async-testing/">异步测试</a></p>
<p><strong>第五篇博客</strong> <a target="_blank" rel="noopener" href="https://bestswifter.com/deep-gcd/">深入理解GCD</a></p>
<p>需要注意的是，这篇博文里还没有dispatch_object的概念，一些方法也进行了比较大的改变，参考即可。</p>
<p>比如：</p>
<p>group已经从long_max的信号量变成了初始值为0的信号量。</p>
<p>dispatch_group_enter也没有调用sema4wait了，而是直接进行-1操作。</p>
<p><strong>Lock In ARM</strong></p>
<p>我们一定需要从硬件上支持lock的存在，目前Inter，AMD，ARM都是基于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MESI%E5%8D%8F%E8%AE%AE">MESI</a>的状态机设计的</p>
<p><a target="_blank" rel="noopener" href="http://infocenter.arm.com/help/topic/com.arm.doc.dht0008a/DHT0008A_arm_synchronization_primitives.pdf">http://infocenter.arm.com/help/topic/com.arm.doc.dht0008a/DHT0008A_arm_synchronization_primitives.pdf</a></p>
<p><strong>总结</strong></p>
<p>GCD是一个非常好的从高级语言深入到硬件机制的库，多线程和缓存永远是程序员手里最强的武器，但是一不小心就一枪崩了自己，跟大家一起多多学习。</p>

    </div>

    <div class="totop">ToTOP</div>
</div>
        <div class="footer">
    <a href="#">
        2018 <i class="fab fa-studiovinari"></i> FOLOBE <i class="fas fa-angle-double-up"></i>
    </a>
</div>


<script src="/js/totop.js"></script>


<script src="/js/search.js"></script>

    </div>
</body>

</html>